创建的每个函数都有一个`prototype`属性，这个属性是一个指针，指向一个对象，而这个对象的用途时包含可以由特定类型的所有实例共享的属性和方法。
## 理解原型对象
## 原型与in操作符
在单独使用时，`in`操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例还是原型中。

可以和`hasOwnProperty`配合确定该属性到底时存在与实例还是原型中
```
function hasPrototypeProperty(o,name){
    return !object.hasOwnProperty(name)&& (name in o)
}
```
要取得对象上所有可枚举的实力属性，可以使用`Object.keys()`方法，返回一个包含所有可枚举属性的字符串数组。

如果想得到所有实例属性可以使用`Object.getOwnPropertyNames()`。

## 原型的动态性
对原型对象所做的任何修改都能够立即从实例上反应出来。

尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反应出来，但如果是重写整个原型对象，那么情况就不一样了。调用构造函数时会为实例添加一个指向最出原型的指针，而把原型修改为另一个对象就等于切断了构造函数和最初原型之间的联系。**实例中的指针仅指向原型，而不指向构造函数。**
## 原生对象的原型
所有原生的引用类型，都是采用这种模式创建的。
## 原型对象的问题
省略了构造函数传递初始化参数这一环节。













































































































